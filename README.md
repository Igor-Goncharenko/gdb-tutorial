# GNU Debugger tutorial
Во время написания кода неизбежно возникают ошибки: неправильный вывод, неправильное значение
переменной, ошибка памяти (segmentation fault). И когда такое происходит, сразу хочется натыкать
print-ов и так посмотреть, что пошло не так. Но такой подход может отловить не все ошибки да и потом
придётся удалять все выводы в терминал (а в большой программе их не всегда просто найти).
Более правильным и универсальным способом является ильзование отладчика (debugger). Здесь мы
рассмотрим использование gdb на примере работы с языком C.

## 1. Запуск отладки
Прежде чем начать работу с отладчиком, надо подготовить программу на C к работе с ним. Для этого
надо добавить два простых флага: 
- `-g`: включение отладочной информации;
- `-O0`: отключение оптимизаций.

Теперь, например, компиляция программы может выглядеть так:
```bash
$ gcc -Wall -Werror -Wextra -std=c11 -O0 -g filename.c -o out
```

Терерь мы готовы включать отладчик, это делаеться командой:
```bash
$ gdb ./out
```

Чтобы запустить программу, нужно в отладчике ввести команду 
```gdb
(gdb) run
```
Также можно передать параметры командной строки: `run 1 2`.

Чтобы закрыть gdb надо ввести команду:
```gdb
(gdb) quit
```

## 2. Вывод информации, команда print
`print` - встроенная команда GDB, которая вычисляет значение выражения на C. Рассмотрим несколько
примеров:

```gdb
(gdb) print 1 + 2
$1 = 3
```
Здесь мы просто вычисляем значение выражения `1 + 2`.

```gdb
(gdb) print (int)2147483648
$2 = -2147483648
```
Мы преобразовываем большое число к типу `int`. Происходит переполнение типа, поэтому мы получаем
отрицательное число.

```gdb
(gdb) print $1
$3 = 3
```
Выводим результат первого вычисления (`$1 = 3`).

Это ещё не все возможности данной команды, но остальные мы рассмотрим немного позже.

## 3. Базовая отладка, команды break и next
Рассмотрим вышеуказанные команды на простом примере:
```c
int main(void) {
    int i = 1432;
    int x = 4329;
    x -= i;
    return 0;
}
```
Скомпилируем эту программу и запустим её с помощью отладчика.
В первую очередь добавим точку остановки (breakpoint) в функции `main`:
```gdb
(gdb) break main
Breakpoint 1 at 0x111d: file test.c, line 2.
```
Мы успешно создали точку остановки в начале функции `main`, теперь можно запустить программу:
```gdb
(gdb) run
Breakpoint 1, main () at test.c:2
2           int i = 1432;
```
Мы достигли ранее созданной точки остановки, можно попробовать вывести переменную `i`:
```gdb
(gdb) print i
$1 = -134329952
```
Переменная ещё не инициализирована, поэтому в ней хранится случайное значение.

Далее будем построчно выполнять программу (для этого используем команду `next`) и следить за 
изменением переменных.
```gdb
(gdb) next
3           int x = 4329;
```
Мы перешли на строку с инициализацией переменной `x`. Попробуем вывести обе переменных:
```gdb
(gdb) print i
$2 = 1432
(gdb) print x
$3 = 32767
```
Переменная `i` теперь имеет заданное в программе значение, а `x` ещё не инициализирована.

Переходим на следующую строку:
```gdb
(gdb) next
4           x -= i;
(gdb) print x
$4 = 4329
```
Теперь и `x` тоже инициализирована.

Выполним предпоследнюю строку с вычитанием:
```gdb
(gdb) next
5           return 0;
(gdb) print x
$5 = 2897
```
Мы выполнили вычитание.

Отладка закончена, можно ввести команду `continue`, чтобы дать программе завершиться.
```gdb
(gdb) continue
Continuing.
[Inferior 1 (process 9002) exited normally]
```
Процесс успешно завершился.

